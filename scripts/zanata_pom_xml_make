#!/usr/bin/env perl
# Insert zanata snippets to pom.xml if not so already.

# Ensure it runs on RHEL5
use 5.008_008;
use strict;
use File::Basename;
use File::Spec;
use File::Slurp;
use File::Copy;
use Getopt::Std;
use Pod::Usage;
use XML::Twig::XPath;
use Data::Dumper;

# path variables
my $scriptDir=dirname($0);
my $xmlSnippetsDir="$scriptDir/../xml_snippets/";
my $pluginSnippet="$xmlSnippetsDir/plugin.pom.xml";
my $pluginRepositorySnippet="$xmlSnippetsDir/pluginRepository.pom.xml";
my $backupSuffix=".stamp";

use lib "scripts";
use Zanata::ReadCfg;
use Zanata::XML;

# Subroutines
sub print_usage {
    die <<END
Insert zanata snippets to pom.xml if not so already.
It will back up the input file as $backupSuffix;

Usage:
    $0 [-h]
    $0 [options] <pom.xml>

Options:
    -h: Display this help.
    -c cfg: cfg file to read.
    -p: Insert pluginRepositories.
    -e pattern: exclude pattern
    -i pattern: include pattern
    -k: skip
    -m: module is enabled.
    -b basedir: base directory
    -s srcdir: source dir to current dir, or releate dir if -b is also specified.
    -t transdir: translation to be outputted
END
}

sub zanataPluginRepoElement_new{
    my ($id, $name, $url, $releases, $snapshots)=@_;
    my $zPRepoStr=<<END;
<pluginRepository>
    <id>$id</id>
    <name>$name</name>
    <url>$url</url>
    <releases>
	<enabled>$releases</enabled>
      </releases>
      <snapshots>
	<enabled>$snapshots</enabled>
      </snapshots>
</pluginRepository>
END

    return Zanata::XML::xml_element_new_xml($zPRepoStr);
}

## Parse arguments
my %opts;
getopts("hcp:e:i:kmb:s:t:", \%opts);
my %optsToPomKeys=(
    "b" => "baseDir"
    , "s" => "srcDir"
    , "t" => "transDir"
    , "m" => "enableModules"
    , "k" => "skip"
    , "i" => "includes"
    , "e" => "excludes"
);

sub zanataPluginElement_new{
    my ($mvnPluginVersion, $isDefault, $optsRef)=@_;
    my $zanataPluginStr=<<END;
<plugin>
    <groupId>org.zanata</groupId>
    <artifactId>zanata-maven-plugin</artifactId>
    <version>$mvnPluginVersion</version>
    <configuration>
    </configuration>
</plugin>
END

    my $zanataPluginElement=Zanata::XML::xml_element_new_xml($zanataPluginStr);
    my $confElt=$zanataPluginElement->first_descendant('configuration');
    if ($isDefault){
	$confElt->insert_new_elt(srcDir => '${zanata.srcDir}');
	$confElt->insert_new_elt('last_child', transDir => '${zanata.transDir}');
    }else{
	if ($optsRef->{'e'}){
	    $confElt->insert_new_elt($optsToPomKeys{'e'} => "$optsRef->{'e'}");
	}

	if ($optsRef->{'i'}){
	    $confElt->insert_new_elt($optsToPomKeys{'i'} => "$optsRef->{'i'}");
	}

	if ($optsRef->{'k'}){
	    $confElt->insert_new_elt($optsToPomKeys{'k'} => "true");
	}

	if ($optsRef->{'m'}){
	    $confElt->insert_new_elt($optsToPomKeys{'m'} => "true");
	}

	my $baseDir=($optsRef->{'b'}) ? $optsRef->{'b'}: ".";

	if ($optsRef->{'s'}){
	    $confElt->insert_new_elt($optsToPomKeys{'s'} => File::Spec->join($baseDir, $optsRef->{'s'}));
	}

	if ($optsRef->{'t'}){
	    $confElt->insert_new_elt($optsToPomKeys{'t'} => File::Spec->join($baseDir, $optsRef->{'t'}));
	}
    }

    return $zanataPluginElement;
}


if (scalar(@ARGV)<1){
    print_usage;
}

if ($opts{'h'}){
    print_usage;
    exit 0;
}

my $cfgFile="test.cfg";
if ($opts{'c'}){
    $cfgFile=$opts{'c'};
}

my $insertPluginRepository=($opts{'p'})? 1 : 0;

my $isDefault=1;
for my $o (keys %optsToPomKeys){
    if ($opts{$o}){
	$isDefault=0;
	last;
    }
}

my $pomXml=$ARGV[0];

# Environment variable hash: init
my $cfgHRef=Zanata::ReadCfg::read_file($cfgFile, 1);

my $twig= XML::Twig::XPath->new( pretty_print=>'indented');

## Parses pom.xml if exists, and backup the original file
if ( -e "$pomXml"){
    copy($pomXml, "$pomXml$backupSuffix");
    ### Parse pom.xml
    $twig->parsefile("$pomXml");
}else{
    open (my $FH, ">$pomXml$backupSuffix") or die "Cannot write to $pomXml$backupSuffix";
    close ($FH);
}

## If /project/build/plugins does not exist
### build up the path
Zanata::XML::build_xpath($twig, '/project/build/plugins');

my $root=$twig->root;

## Insert zanata plugin if not already exists.
my @zanataPluginL=$twig->findnodes('/project/build/plugins/plugin[groupId="org.zanata"]');
unless (@zanataPluginL){
    my $zanataPluginElement= zanataPluginElement_new($cfgHRef->{'MVN_CLIENT_VER'} , $isDefault, \%opts);
    my @zanataPluginsL=$twig->findnodes('/project/build/plugins');
    unless (@zanataPluginsL){
	$twig->print;
	die "/project/build/plugins not found!";  }
    $zanataPluginElement->paste('first_child', $zanataPluginsL[0]);
}

## Insert zanata pluginRepository if required but not already exists.
if ($insertPluginRepository){
    ### build up the path
    Zanata::XML::build_xpath($twig, '/project/pluginRepositories');

    my @zanataPluginRepositoriesL=$twig->findnodes('/project/pluginRepositories');
    my $zanataPluginRepositories=$zanataPluginRepositoriesL[0];
    ### Read cfg about plugin repositories
    print "mvn_repos=$cfgHRef->{'ZANATA_MVN_REPOS'}\n";
    my @pluginRepos=split(/;/,$cfgHRef->{'ZANATA_MVN_REPOS'});

    ### Foreach plugin repository
    for my $pluginRepo (@pluginRepos){
	my $id=$cfgHRef->{"${pluginRepo}_ID"};
	my @zanataPluginRepositoryL= $twig->findnodes('/project/pluginRepositories/pluginRepository[id="$id"]');
	#### If plugin repository id does not exists in pom.xml, then
	unless( @zanataPluginRepositoryL){
	    my $name=$cfgHRef->{"${pluginRepo}_NAME"};
	    my $url= $cfgHRef->{"${pluginRepo}_URL"};

	    ##### plugin repository element new
	    my $zPluginRepoElt=zanataPluginRepoElement_new("$id", "$name", "$url", 'true', 'true');

	    ##### insert to /project/pluginRepositories
	    $zPluginRepoElt->paste($zanataPluginRepositories);
	}



    }
}

$twig->print;
